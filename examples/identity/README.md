# Identity

This example showcases how an SVG image can be generated using an on-chain program by concatenating other on-chain SVG parts stored using the Data Program

## End Goal

A visual SVG avatar representation of a `PublicKey` (`identity`)

## Features

* The SVG avatars are algorithmically generated from unique SVG parts for Environment, Head, Clothes, Top, Eyes, and Mouth using the `identity` as the seed
* The colors are also generated algorithmically using the `identity` as the seed
* SVG part assets that are currently used are https://multiavatar.com/ assets that have been minified to stay within compute limits. However, the [Usage Instructions](#usage-instructions) describe how one could use custom assets too.
* The SVG avatar generated is unique for every `PublicKey` (although visually with how hex color codes work, under pretty unlikely circumstances, some SVG's may look similar)

## Implementation

* **Colors**: 
  - Colors are generated by taking the sine of a few (depends on the part) LE bytes of the SHA256 hash of the `identity` seed and normalizing it to a valid Hexadecimal value
  - In cases where the part uses a 3-digit hexadecimal as the default `fill` value, the first three hexadecimal digits of the generated color is used to replace the default `fill` value
  - Otherwise, all six hexadecimal digits are used to replace the default `fill` value
* **Environment**:
  - Currently there is only a single Environment SVG part with `fill:#01`
  - The `fill` value is replaced with the color generated using the first 16 LE bytes of the SHA256 hash of the `identity` seed
* **Head**:
  - Currently there is only a single Head SVG part with `fill:#000`
  - The `fill` value is replaced with the color generated using the last 16 LE bytes of the SHA256 hash of the `identity` seed
* **Clothes**:
  - All the Clothes SVG parts would be passed as accounts to the instruction and the SVG part would be randomly chosen by taking the mod of the first 8 LE bytes of the SHA256 hash of the `identity` seed by the total number of account parts
  - The `fill` value is determined using the first 8 LE bytes of the SHA256 hash of the `identity` seed
* **Top**:
  - All the Top SVG parts would be passed as accounts to the instruction and the SVG part would be randomly chosen by taking the mod of the second 8 LE bytes of the SHA256 hash of the `identity` seed by the total number of account parts
  - The `fill` value is determined using the second 8 LE bytes of the SHA256 hash of the `identity` seed
* **Eyes**:
  - All the Eyes SVG parts would be passed as accounts to the instruction and the SVG part would be randomly chosen by taking the mod of the third 8 LE bytes of the SHA256 hash of the `identity` seed by the total number of account parts
  - The `fill` value is determined using the third 8 LE bytes of the SHA256 hash of the `identity` seed
* **Mouth**:
  - All the Mouth SVG parts would be passed as accounts to the instruction and the SVG part would be randomly chosen by taking the mod of the last 8 LE bytes of the SHA256 hash of the `identity` seed by the total number of account parts
  - The `fill` value is determined using the last 8 LE bytes of the SHA256 hash of the `identity` seed

## Usage instructions

1. Clone the example and navigate to the `program` directory
2. Compile the Rust program using: `cargo-build-sbf`
3. Deploy the Rust program using: `solana program deploy target/deploy/identityprogram.so`. <br />
<b>Note down the program ID of the deployed program</b>
4. Navigate the `js` directory and install all dependencies using `npm install`
5. Create a `.env` file and add the following to it:
```
CONNECTION_URL=https://api.devnet.solana.com # if deployed on devnet
CLUSTER=devnet # if deployed on devnet
DATA_PROGRAM_ID=ECQd7f4sYhcWX5G9DQ7Hgcf3URZTfgwVwjKzH2sMQeFW # if deployed on devnet
IDENTITY_PROGRAM_ID=<REPLACE WITH PROGRAM ID OF THE DEPLOYED RUST PROGRAM>
AUTHORITY_PRIVATE=<REPLACE WITH PRIVATE KEY OF AUTHORITY WALLET>
```
  <b>If you'd like to use the default SVGs, you can skip to step 11. Steps 6-10 discuss how to use custom SVG parts.</b>

6. Run `npx ts-node src/index.ts --generate` to generate the original SVG parts. The parts will be stored in a `og-svgs.txt` file
7. In order to get over compute limits, minify each SVG individually using any online tool like https://svgomg.net/
8. Store the minified SVG data in `svgs.ts`
9. Once all SVGs are minified, run `npx ts-node src/index.ts --upload` to upload all the parts to separate Data Accounts. The `PublicKey`s will be displayed on the console so make sure you copy them over and update the `svg-pubkeys.ts` file
10. You can also manually upload parts individually using [SolD](https://sold-website.vercel.app/upload) and copy over the `PublicKey` of the Data Account there
11. Once you are happy with the SVG parts' `PublicKey`s in `svg-pubkeys.ts`, you can now generate the avatars
12. Run the following to create a new Data Account that will store the avatar generated using the `identity` as the seed:
```
npx ts-node src/index.ts --identity <REPLACE WITH IDENTITY PUBKEY>
```
14. If you already have a dynamic Data Account, you can alternatively run the following to store the avatar generated using the `identity` as the seed in the `account` Data Account:
```
npx ts-node src/index.ts --account <REPLACE WITH DATA ACCOUNT PUBKEY TO STORE SVG> --identity <REPLACE WITH IDENTITY PUBKEY>
```

You now have a unique avatar that is a visual representation of your `PublicKey` that is generated fully on-chain! ;)
